; 主引导程序
; LOADER_BASE_ADDR equ 0xA000
; LOADER_START_SECTOR equ 0x2
;-----------------------------------------------------
SECTION MBR vstart=0x7c00 ; 起始地址编译为 0x7c00
    mov ax,cs   ; ax为通用寄存器,ds/es/fs/gs为段寄存器
    mov ds,ax   ; CPU 不能直接从立即数到段寄存器，需要通过其他寄存器中转
    mov es,ax   ; 这里使用 ax 转化
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00 ; 初始化栈指针（栈是向低地址生长的），0x7c00 向上是MBR的代码，向下为可使用的安全区域，作为栈使用
    mov ax,0xb800
    mov gs,ax

; 清屏 : 利用 0x06 号功能，上卷全部行，则可清屏
;-----------------------------------------------------
; INT 0x10  功能号:0x06  功能描述 : 上卷窗口
;-----------------------------------------------------
; 输入 : 
; AH    功能号 = 0x06
; AL    =   上卷的行数（如果为0，表示全部）
; BH    =   上卷行属性
; (CL,CH) = 窗口左上角的 (X,Y)位置
; (DL,DH) = 窗口右下角的 (X,Y)位置
; 无返回值:
    mov ax, 0600h
    mov bx, 0700h
    mov cx, 0       ; 左上角 : (0, 0)
    mov dx, 184fh  	; 右下角 : (80, 25)
                    ; VGA 文本模式下，一行只能容纳 80 个字符，共 25 行
                    ; 下标从 0 开始，故 0x18=24, 0x4f=79
    int 10h         ; int 0x10

;-----------------------------------------------------
; 输出绿底红字，且跳动的字符串 "1 MBR"
;-----------------------------------------------------
    mov byte [gs:0x00],'1'
    mov byte [gs:0x01],0xA4
    ; 0xA4 即为 1010 0100 
    ; 第一个1表示闪烁，第2个表示绿背景，第三个表示红字
    mov byte [gs:0x02],' '
    mov byte [gs:0x03],0xA4
    
    mov byte [gs:0x04],'M'
    mov byte [gs:0x05],0xA4
    
    mov byte [gs:0x06],'B'
    mov byte [gs:0x07],0xA4
    
    mov byte [gs:0x08],'R'
    mov byte [gs:0x09],0xA4

;-----------------------------------------------------
; 死循环使得程序停在此处
;-----------------------------------------------------
    jmp $
;-----------------------------------------------------
; 字符填充
; 510 字节减去上面通过($-$$)得到的偏移量，其结果便是本扇区
; 内的剩余量，也就是要填充的字节数。
;-----------------------------------------------------
    times 510-($-$$) db 0
;-----------------------------------------------------
; 保证最后两个字节为 0x55, 0xaa
;-----------------------------------------------------
    db 0x55,0xaa